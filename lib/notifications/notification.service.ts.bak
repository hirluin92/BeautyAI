// Path: lib/services/notification.service.ts
import { createClient } from '@/lib/supabase/server'
import { SupabaseClient } from '@supabase/supabase-js'
import { format, addDays, startOfDay, endOfDay } from 'date-fns'
import { it } from 'date-fns/locale'

export interface NotificationConfig {
  emailjs: {
    serviceId: string
    templateId: string
    publicKey: string
  }
  twilio?: {
    accountSid: string
    authToken: string
    phoneNumber: string
  }
}

export interface NotificationData {
  bookingId: string
  clientName: string
  clientEmail?: string
  clientPhone?: string
  serviceName: string
  staffName?: string
  date: string
  time: string
  duration: number
  price: number
  organizationName: string
  organizationPhone?: string
  notificationPreferences: {
    email: boolean
    sms: boolean
    whatsapp: boolean
  }
}

export type NotificationType = 'confirmation' | 'reminder_24h' | 'reminder_1h' | 'cancellation' | 'modification'

export class NotificationService {
  private supabase: SupabaseClient | null = null
  private config: NotificationConfig

  constructor(config: NotificationConfig) {
    this.config = config
    this.initializeSupabase()
  }

  private async initializeSupabase() {
    this.supabase = await createClient()
  }

  /**
   * Invia notifica basata sul tipo e preferenze del cliente
   */
  async sendNotification(type: NotificationType, data: NotificationData) {
    const results = {
      email: { sent: false, error: null as string | null },
      sms: { sent: false, error: null as string | null },
      whatsapp: { sent: false, error: null as string | null }
    }

    try {
      // Email notification
      if (data.notificationPreferences.email && data.clientEmail) {
        try {
          await this.sendEmailNotification(type, data)
          results.email.sent = true
        } catch (error: any) {
          results.email.error = error.message
        }
      }

      // SMS notification
      if (data.notificationPreferences.sms && data.clientPhone && this.config.twilio) {
        try {
          await this.sendSMSNotification(type, data)
          results.sms.sent = true
        } catch (error: any) {
          results.sms.error = error.message
        }
      }

      // WhatsApp notification
      if (data.notificationPreferences.whatsapp && data.clientPhone) {
        try {
          await this.sendWhatsAppNotification(type, data)
          results.whatsapp.sent = true
        } catch (error: any) {
          results.whatsapp.error = error.message
        }
      }

      // Log notification in database
      await this.logNotification(type, data, results)

      // Update booking notification status
      await this.updateBookingNotificationStatus(data.bookingId, type)

      return results
    } catch (error) {
      console.error('Error sending notifications:', error)
      throw error
    }
  }

  /**
   * Invia notifica email usando EmailJS
   */
  private async sendEmailNotification(type: NotificationType, data: NotificationData) {
    const emailData = {
      service_id: this.config.emailjs.serviceId,
      template_id: this.config.emailjs.templateId,
      user_id: this.config.emailjs.publicKey,
      template_params: {
        to_email: data.clientEmail,
        to_name: data.clientName,
        from_name: data.organizationName,
        service_name: data.serviceName,
        appointment_date: data.date,
        appointment_time: data.time,
        staff_name: data.staffName || 'Non assegnato',
        duration: `${data.duration} minuti`,
        price: `‚Ç¨${data.price}`,
        organization_phone: data.organizationPhone,
        message: this.getEmailMessage(type, data)
      }
    }

    const response = await fetch('https://api.emailjs.com/api/v1.0/email/send', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(emailData)
    })

    if (!response.ok) {
      throw new Error(`EmailJS error: ${response.status}`)
    }

    return response
  }

  /**
   * Invia SMS usando Twilio
   */
  private async sendSMSNotification(type: NotificationType, data: NotificationData) {
    if (!this.config.twilio) {
      throw new Error('Twilio configuration missing')
    }

    const message = this.getSMSMessage(type, data)
    const to = this.formatPhoneNumber(data.clientPhone!)

    const auth = Buffer.from(
      `${this.config.twilio.accountSid}:${this.config.twilio.authToken}`
    ).toString('base64')

    const response = await fetch(
      `https://api.twilio.com/2010-04-01/Accounts/${this.config.twilio.accountSid}/Messages.json`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${auth}`,
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          To: to,
          From: this.config.twilio.phoneNumber,
          Body: message
        })
      }
    )

    if (!response.ok) {
      const error = await response.json()
      throw new Error(`Twilio error: ${error.message}`)
    }

    return response
  }

  /**
   * Invia notifica WhatsApp
   */
  private async sendWhatsAppNotification(type: NotificationType, data: NotificationData) {
    const message = this.getWhatsAppMessage(type, data)
    const link = this.createWhatsAppLink(data.clientPhone!, message)
    
    // Log the WhatsApp link for manual sending
    console.log('WhatsApp link:', link)
    
    // If Twilio WhatsApp is configured, send automatically
    if (this.config.twilio) {
      const auth = Buffer.from(
        `${this.config.twilio.accountSid}:${this.config.twilio.authToken}`
      ).toString('base64')

      const response = await fetch(
        `https://api.twilio.com/2010-04-01/Accounts/${this.config.twilio.accountSid}/Messages.json`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Basic ${auth}`,
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            To: `whatsapp:${this.formatPhoneNumber(data.clientPhone!)}`,
            From: `whatsapp:${this.config.twilio.phoneNumber}`,
            Body: message
          })
        }
      )

      if (!response.ok) {
        const error = await response.json()
        throw new Error(`Twilio WhatsApp error: ${error.message}`)
      }

      return response
    }

    // Return success for manual method
    return { ok: true, manual: true, link }
  }

  /**
   * Ottieni messaggio email basato sul tipo
   */
  private getEmailMessage(type: NotificationType, data: NotificationData): string {
    const templates = {
      confirmation: `Gentile ${data.clientName},\n\nLa sua prenotazione √® stata confermata!\n\nDettagli:\n- Servizio: ${data.serviceName}\n- Data: ${data.date}\n- Ora: ${data.time}\n- Durata: ${data.duration} minuti\n- Prezzo: ‚Ç¨${data.price}\n${data.staffName ? `- Operatore: ${data.staffName}` : ''}\n\nLa aspettiamo!\n\n${data.organizationName}`,
      
      reminder_24h: `Gentile ${data.clientName},\n\nLe ricordiamo il suo appuntamento di domani:\n\n- Servizio: ${data.serviceName}\n- Data: ${data.date}\n- Ora: ${data.time}\n\nA domani!\n\n${data.organizationName}`,
      
      reminder_1h: `Gentile ${data.clientName},\n\nTra un'ora ha l'appuntamento per ${data.serviceName}.\n\nLa aspettiamo alle ${data.time}!\n\n${data.organizationName}`,
      
      cancellation: `Gentile ${data.clientName},\n\nIl suo appuntamento del ${data.date} alle ${data.time} √® stato annullato.\n\nPer riprenotare, ci contatti al ${data.organizationPhone}.\n\nGrazie,\n${data.organizationName}`,
      
      modification: `Gentile ${data.clientName},\n\nIl suo appuntamento √® stato modificato.\n\nNuovi dettagli:\n- Servizio: ${data.serviceName}\n- Data: ${data.date}\n- Ora: ${data.time}\n\nGrazie,\n${data.organizationName}`
    }

    return templates[type] || ''
  }

  /**
   * Ottieni messaggio SMS basato sul tipo
   */
  private getSMSMessage(type: NotificationType, data: NotificationData): string {
    const templates = {
      confirmation: `Confermato: ${data.serviceName} il ${data.date} alle ${data.time}. ${data.organizationName}`,
      
      reminder_24h: `Promemoria: domani alle ${data.time} - ${data.serviceName}. ${data.organizationName}`,
      
      reminder_1h: `Tra 1 ora: ${data.serviceName} alle ${data.time}. Ti aspettiamo! ${data.organizationName}`,
      
      cancellation: `Annullato: appuntamento del ${data.date}. Chiama ${data.organizationPhone} per riprenotare. ${data.organizationName}`,
      
      modification: `Modificato: ${data.serviceName} spostato al ${data.date} alle ${data.time}. ${data.organizationName}`
    }

    return templates[type] || ''
  }

  /**
   * Ottieni messaggio WhatsApp basato sul tipo
   */
  private getWhatsAppMessage(type: NotificationType, data: NotificationData): string {
    const templates = {
      confirmation: `‚úÖ *Prenotazione Confermata*\n\nCiao ${data.clientName}! üëã\n\nTi confermiamo la prenotazione:\nüìÖ ${data.date}\n‚è∞ ${data.time}\nüíÜ ${data.serviceName}\n${data.staffName ? `üë§ ${data.staffName}` : ''}\nüí∞ ‚Ç¨${data.price}\n\nTi aspettiamo!\n${data.organizationName}`,
      
      reminder_24h: `‚è∞ *Promemoria Appuntamento*\n\nCiao ${data.clientName}!\n\nTi ricordiamo l'appuntamento di domani:\nüìÖ ${data.date}\n‚è∞ ${data.time}\nüíÜ ${data.serviceName}\n\nA domani! üòä\n${data.organizationName}`,
      
      reminder_1h: `üîî *Tra 1 ora!*\n\nCiao ${data.clientName}!\n\nTra poco ti aspettiamo per:\n‚è∞ ${data.time}\nüíÜ ${data.serviceName}\n\nA presto! üéâ\n${data.organizationName}`,
      
      cancellation: `‚ùå *Appuntamento Annullato*\n\nCiao ${data.clientName},\n\nIl tuo appuntamento del ${data.date} alle ${data.time} √® stato annullato.\n\nüìû Chiamaci al ${data.organizationPhone} per riprenotare!\n\n${data.organizationName}`,
      
      modification: `üìù *Appuntamento Modificato*\n\nCiao ${data.clientName}!\n\nIl tuo appuntamento √® stato modificato:\nüìÖ ${data.date}\n‚è∞ ${data.time}\nüíÜ ${data.serviceName}\n\nGrazie!\n${data.organizationName}`
    }

    return templates[type] || ''
  }

  /**
   * Formatta numero di telefono per API
   */
  private formatPhoneNumber(phone: string): string {
    // Rimuovi spazi e caratteri speciali
    let cleaned = phone.replace(/\D/g, '')
    
    // Aggiungi prefisso Italia se non presente
    if (!cleaned.startsWith('39') && cleaned.length === 10) {
      cleaned = '39' + cleaned
    }
    
    // Aggiungi + se non presente
    if (!cleaned.startsWith('+')) {
      cleaned = '+' + cleaned
    }
    
    return cleaned
  }

  /**
   * Crea link WhatsApp per invio manuale
   */
  private createWhatsAppLink(phone: string, message: string): string {
    const cleanPhone = phone.replace(/[^\d]/g, '')
    const phoneWithPrefix = cleanPhone.startsWith('39') ? cleanPhone : `39${cleanPhone}`
    return `https://wa.me/${phoneWithPrefix}?text=${encodeURIComponent(message)}`
  }

  /**
   * Log notifica nel database
   */
  private async logNotification(
    type: NotificationType,
    data: NotificationData,
    results: any
  ) {
    if (!this.supabase) {
      console.error('Supabase client not initialized')
      return
    }

    const { error } = await this.supabase
      .from('notification_logs')
      .insert({
        booking_id: data.bookingId,
        client_id: data.clientName, // TODO: Use actual client ID
        type: type,
        status: this.getNotificationStatus(results),
        message: this.getNotificationMessage(type, data),
        sent_at: new Date().toISOString(),
        metadata: {
          email_sent: results.email.sent,
          sms_sent: results.sms.sent,
          whatsapp_sent: results.whatsapp.sent,
          email_error: results.email.error,
          sms_error: results.sms.error,
          whatsapp_error: results.whatsapp.error
        }
      })

    if (error) {
      console.error('Error logging notification:', error)
    }
  }

  private getNotificationStatus(results: any): string {
    if (results.email.sent || results.sms.sent || results.whatsapp.sent) {
      return 'sent'
    }
    return 'failed'
  }

  private getNotificationMessage(type: NotificationType, data: NotificationData): string {
    return `${type} notification for ${data.clientName} - ${data.serviceName} on ${data.date} at ${data.time}`
  }

  /**
   * Aggiorna stato notifica del booking
   */
  private async updateBookingNotificationStatus(bookingId: string, type: NotificationType) {
    if (!this.supabase) {
      console.error('Supabase client not initialized')
      return
    }

    const fieldMap: Record<NotificationType, string> = {
      confirmation: 'confirmation_sent',
      reminder_24h: 'reminder_24h_sent',
      reminder_1h: 'reminder_1h_sent',
      cancellation: 'cancellation_sent',
      modification: 'modification_sent'
    }

    const field = fieldMap[type]
    if (!field) return

    const { error } = await this.supabase
      .from('bookings')
      .update({
        [field]: true,
        [field + '_at']: new Date().toISOString()
      })
      .eq('id', bookingId)

    if (error) {
      console.error('Error updating booking notification status:', error)
    }
  }

  /**
   * Ottieni organization_id dell'utente corrente
   */
  private async getOrganizationId(): Promise<string> {
    if (!this.supabase) {
      throw new Error('Supabase client not initialized')
    }

    // TODO: Get from context or environment
    const { data, error } = await this.supabase
      .from('organizations')
      .select('id')
      .limit(1)
      .single()

    if (error || !data) {
      throw new Error('Organization not found')
    }

    return data.id
  }

  /**
   * Ottieni prenotazioni che necessitano reminder
   */
  async getBookingsNeedingReminders(type: 'reminder_24h' | 'reminder_1h') {
    if (!this.supabase) {
      throw new Error('Supabase client not initialized')
    }

    const now = new Date()
    const tomorrow = addDays(now, 1)
    const tomorrowStart = startOfDay(tomorrow)
    const tomorrowEnd = endOfDay(tomorrow)

    const reminderField = type === 'reminder_24h' ? 'reminder_24h_sent' : 'reminder_1h_sent'

    const { data: bookings, error } = await this.supabase
      .from('bookings')
      .select(`
        id,
        client_name,
        client_email,
        client_phone,
        service_name,
        staff_name,
        start_at,
        appointment_time,
        duration_minutes,
        price,
        ${reminderField}
      `)
      .eq('status', 'confirmed')
      .gte('start_at', tomorrowStart.toISOString())
      .lte('start_at', tomorrowEnd.toISOString())
      .eq(reminderField, false)
      .order('start_at', { ascending: true })

    if (error) {
      console.error('Error fetching bookings needing reminders:', error)
      return []
    }

    return bookings || []
  }

  /**
   * Invia tutti i reminder per le prenotazioni
   */
  async sendBatchReminders(type: 'reminder_24h' | 'reminder_1h') {
    const bookings = await this.getBookingsNeedingReminders(type)
    const results = []

    for (const booking of bookings) {
      try {
        const notificationData: NotificationData = {
          bookingId: booking.id,
          clientName: booking.client_name,
          clientEmail: booking.client_email,
          clientPhone: booking.client_phone,
          serviceName: booking.service_name,
          staffName: booking.staff_name,
          date: format(new Date(booking.start_at), 'EEEE d MMMM', { locale: it }),
          time: format(new Date(booking.start_at), 'HH:mm'),
          duration: booking.duration_minutes,
          price: booking.price,
          organizationName: await this.getOrganizationName(),
          organizationPhone: await this.getOrganizationPhone(),
          notificationPreferences: {
            email: true,
            sms: true,
            whatsapp: true
          }
        }

        const result = await this.sendNotification(type, notificationData)
        results.push({ bookingId: booking.id, success: true, result })
      } catch (error) {
        console.error(`Error sending reminder for booking ${booking.id}:`, error)
        results.push({ bookingId: booking.id, success: false, error })
      }
    }

    return results
  }

  /**
   * Ottieni nome organizzazione
   */
  private async getOrganizationName(): Promise<string> {
    if (!this.supabase) {
      throw new Error('Supabase client not initialized')
    }

    const { data, error } = await this.supabase
      .from('organizations')
      .select('name')
      .limit(1)
      .single()

    if (error || !data) {
      return 'Centro Estetico'
    }

    return data.name
  }

  /**
   * Ottieni telefono organizzazione
   */
  private async getOrganizationPhone(): Promise<string> {
    if (!this.supabase) {
      throw new Error('Supabase client not initialized')
    }

    const { data, error } = await this.supabase
      .from('organizations')
      .select('phone')
      .limit(1)
      .single()

    if (error || !data) {
      return ''
    }

    return data.phone || ''
  }
}